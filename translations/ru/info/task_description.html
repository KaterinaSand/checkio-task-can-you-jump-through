<p>
    Если вы решили задачу
    <a href="http://www.checkio.org/mission/find-friends/share/3061fec1b35588e4bae8ad69db073aab/">
        "How to find friends"</a>
    то знаете, как проверять существование пути в графе между двумя вершинами.
    Давайте немного усложним.
</p>

<p>
    Дана матрица с цифрами и координаты (строка и столбец) двух клеток с одинаковым значением.
    Вы можете перемещаться между соседними клетками с одинаковыми значениями по вертикали и горизонтали.
    Определите есть ли путь между двумя заданными клетками.
</p>

<p>
    Матрица представлена, как массив массивов с цифрами.
    Координаты представлены, как два числа: строка и столбец.
    Результат проверяется, как булево значение.
    Есть путь существует - True, иначе - False.
</p>

<p style="text-align: center">
    <img src="{{ MEDIA }}can-jump-through.svg" alt="can-you-jump-through" style="max-width: 430px">
</p>

<p>
    <strong>Входные данные: </strong>
    Три аргумента. Матрица, как список списков с целыми числами.
    Координаты двух клеток, как список с двумя целыми числами в каждом.
</p>

<p><strong>Выходные данные: </strong>
    Существование пути между данными клетками, как булево значение (bool).
</p>

<div class="for_info_only"><strong>Примеры:</strong>
<pre class="brush: python">
{% if interpreter.slug == "js-node" %}
<pre class="brush: javascript">
canPass([[0, 0, 0, 0, 0, 0],
         [0, 2, 2, 2, 3, 2],
         [0, 2, 0, 0, 0, 2],
         [0, 2, 0, 2, 0, 2],
         [0, 2, 2, 2, 0, 2],
         [0, 0, 0, 0, 0, 2],
         [2, 2, 2, 2, 2, 2]],
         [3, 2], [0, 5]) == true
canPass([[0, 0, 0, 0, 0, 0],
         [0, 2, 2, 2, 3, 2],
         [0, 2, 0, 0, 0, 2],
         [0, 2, 0, 2, 0, 2],
         [0, 2, 2, 2, 0, 2],
         [0, 0, 0, 0, 0, 2],
         [2, 2, 2, 2, 2, 2]],
         [3, 3], [6, 0]) == false
</pre>
{% else %}
<pre class="brush: python">
can_pass(((0, 0, 0, 0, 0, 0),
          (0, 2, 2, 2, 3, 2),
          (0, 2, 0, 0, 0, 2),
          (0, 2, 0, 2, 0, 2),
          (0, 2, 2, 2, 0, 2),
          (0, 0, 0, 0, 0, 2),
          (2, 2, 2, 2, 2, 2),),
          (3, 2), (0, 5)) == True, 'First example'
can_pass(((0, 0, 0, 0, 0, 0),
          (0, 2, 2, 2, 3, 2),
          (0, 2, 0, 0, 0, 2),
          (0, 2, 0, 2, 0, 2),
          (0, 2, 2, 2, 0, 2),
          (0, 0, 0, 0, 0, 2),
          (2, 2, 2, 2, 2, 2),),
          (3, 3), (6, 0)) == False,
</pre>
{% endif %}
</div>

<p class="for_info_only">
    <strong>Как это используется: </strong>
    Иногда нам не нужна полная реализация алгоритма поиска пути и достаточно
    определить проходимость, а не сам путь.
</p>

<p>
    <strong>Предусловия:</strong><br>
    1 &lt; len(matrix) &le; 10<br>
    all(1 &lt; len(row) &le; 10 for row in matrix)<br>
    all(all(0 &le; x &lt; 10 for x in row) for row in matrix)<br>
    matrix[first[0]][first[1]] == matrix[second[0]][second[1]]<br>
    first != second
</p>
